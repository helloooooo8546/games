<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Runner</title>
  <style>
    :root {
      --bg: #0a0f1e;
      --fg: #e2e8f0;
      --neon1: #00f5ff;
      --neon2: #ff2df1;
      --neon3: #8cff00;
      --accent: #ffc400;
    }

    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1000px 600px at 20% 10%, #0f1630 0%, var(--bg) 50%, #050913 100%);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100vh;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 18px;
      backdrop-filter: blur(6px);
      background: rgba(10, 15, 30, 0.45);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }

    header h1 {
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.5px;
      font-size: 18px;
      color: var(--neon1);
      text-shadow:
        0 0 8px rgba(0,245,255,0.6),
        0 0 20px rgba(0,245,255,0.3);
    }

    .btns {
      display: flex;
      gap: 8px;
    }

    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.15);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: var(--fg);
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    button:hover {
      border-color: rgba(255,255,255,0.35);
      box-shadow: 0 6px 18px rgba(0,0,0,0.35), 0 0 12px rgba(0,245,255,0.25);
      transform: translateY(-1px);
    }

    #game {
      display: grid;
      place-items: center;
      padding: 16px;
    }

    canvas {
      width: min(92vw, 900px);
      height: min(60vh, 520px);
      max-width: 900px;
      aspect-ratio: 16 / 10;
      border-radius: 16px;
      box-shadow:
        0 20px 45px rgba(0,0,0,0.55),
        inset 0 0 60px rgba(0,245,255,0.09),
        inset 0 0 120px rgba(255,45,241,0.05);
      background: radial-gradient(900px 520px at 70% 40%, rgba(0,245,255,0.10), rgba(255,45,241,0.10) 40%, rgba(10,15,30,1) 60%);
    }

    footer {
      display: grid;
      gap: 8px;
      padding: 14px 18px 20px;
      color: #b8c2cc;
      font-size: 14px;
      opacity: 0.95;
    }

    .kbd {
      display: inline-block;
      border: 1px solid rgba(255,255,255,0.15);
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 12px;
      background: rgba(255,255,255,0.06);
      color: var(--fg);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Neon Runner</h1>
      <div class="btns">
        <button id="btnStart">Start</button>
        <button id="btnPause">Pause</button>
        <button id="btnReset">Reset</button>
      </div>
    </header>

    <main id="game">
      <canvas id="canvas" width="900" height="560" aria-label="Neon Runner game"></canvas>
    </main>

    <footer>
      <div>
        <span class="kbd">←</span> <span class="kbd">→</span> to move, <span class="kbd">Space</span> to dash.
        Avoid hazards, collect energy orbs, survive and score big.
      </div>
      <div>
        Tip: Dashing grants brief invulnerability and pierces obstacles, but drains energy. Timing is everything.
      </div>
    </footer>
  </div>

  <script>
    // Utility random
    const rand = (min, max) => Math.random() * (max - min) + min;

    // Setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    // Game state
    const state = {
      running: false,
      paused: false,
      time: 0,
      score: 0,
      hiScore: Number(localStorage.getItem('neon_hi')) || 0,
      energy: 100,
      difficulty: 1,
      player: { x: W * 0.5, y: H * 0.75, vx: 0, w: 36, h: 36, dash: 0, cool: 0, alive: true },
      hazards: [],
      orbs: [],
      trails: [],
      stars: [],
    };

    // Input
    const input = { left: false, right: false, dash: false };

    // Create starfield
    for (let i = 0; i < 180; i++) {
      state.stars.push({
        x: rand(0, W), y: rand(0, H),
        r: rand(0.6, 2.4),
        s: rand(0.2, 1.2),
        c: Math.random() < 0.6 ? 'rgba(0,245,255,0.7)' : 'rgba(255,45,241,0.7)',
      });
    }

    // Controls
    window.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowLeft') input.left = true;
      if (e.code === 'ArrowRight') input.right = true;
      if (e.code === 'Space') input.dash = true;
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft') input.left = false;
      if (e.code === 'ArrowRight') input.right = false;
      if (e.code === 'Space') input.dash = false;
    });

    document.getElementById('btnStart').onclick = () => {
      if (!state.running) startGame();
      state.paused = false;
    };
    document.getElementById('btnPause').onclick = () => { state.paused = !state.paused; };
    document.getElementById('btnReset').onclick = () => resetGame();

    function startGame() {
      state.running = true;
      state.time = 0;
      state.score = 0;
      state.energy = 100;
      state.difficulty = 1;
      state.player = { x: W * 0.5, y: H * 0.75, vx: 0, w: 36, h: 36, dash: 0, cool: 0, alive: true };
      state.hazards = [];
      state.orbs = [];
      state.trails = [];
      loop(0);
    }

    function resetGame() {
      state.running = false;
      state.paused = false;
      startGame();
    }

    // Spawners
    function spawnHazard() {
      const size = rand(22, 48);
      const speed = rand(2.4, 5.2) + state.difficulty * 0.2;
      const x = rand(size, W - size);
      const rotSpeed = rand(-0.04, 0.06);
      const hue = Math.random() < 0.5 ? 'rgba(255,45,241,' : 'rgba(0,245,255,';
      state.hazards.push({
        x, y: -size, w: size, h: size, vy: speed,
        rot: rand(0, Math.PI * 2), rotSpeed,
        color: hue, pulse: rand(0.7, 1.4)
      });
    }

    function spawnOrb() {
      const size = rand(14, 22);
      const speed = rand(2.0, 4.0);
      const x = rand(size, W - size);
      state.orbs.push({
        x, y: -size, w: size, h: size, vy: speed,
        glow: rand(0.4, 1.0)
      });
    }

    // Collision helper
    function collide(a, b) {
      return (Math.abs(a.x - b.x) * 2 < a.w + b.w) &&
             (Math.abs(a.y - b.y) * 2 < a.h + b.h);
    }

    // Trail particles
    function addTrail(x, y, color='rgba(0,245,255,0.5)') {
      state.trails.push({
        x, y, r: rand(3, 7), life: rand(0.3, 0.8), color
      });
    }

    // Draw functions
    function drawStarfield(dt) {
      for (const s of state.stars) {
        s.y += s.s * dt * 60 * 0.06;
        if (s.y > H) { s.y = -2; s.x = rand(0, W); }
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fillStyle = s.c;
        ctx.fill();
      }
    }

    function drawPlayer(p, t) {
      // Glow body
      const g = ctx.createLinearGradient(p.x - p.w, p.y - p.h, p.x + p.w, p.y + p.h);
      g.addColorStop(0, 'rgba(0,245,255,0.8)');
      g.addColorStop(1, 'rgba(255,45,241,0.8)');

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.shadowColor = 'rgba(0,245,255,0.7)';
      ctx.shadowBlur = 25 + (p.dash > 0 ? 30 : 0);

      ctx.beginPath();
      ctx.roundRect(-p.w/2, -p.h/2, p.w, p.h, 8);
      ctx.fillStyle = g;
      ctx.fill();

      // Accent
      ctx.strokeStyle = p.dash > 0 ? 'rgba(255,196,0,0.9)' : 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2.5;
      ctx.stroke();

      // Pulse lines
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(-p.w/2, 0);
      ctx.lineTo(p.w/2, 0);
      ctx.strokeStyle = 'rgba(255,196,0,0.6)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.restore();
    }

    function drawHazard(h, t) {
      ctx.save();
      ctx.translate(h.x, h.y);
      ctx.rotate(h.rot);
      ctx.shadowColor = h.color + '0.8)';
      ctx.shadowBlur = 25;

      ctx.beginPath();
      const s = h.w;
      ctx.moveTo(-s/2, -s/2);
      ctx.lineTo(s/2, -s/2);
      ctx.lineTo(s/2, s/2);
      ctx.lineTo(-s/2, s/2);
      ctx.closePath();
      ctx.strokeStyle = h.color + '0.9)';
      ctx.lineWidth = 2.5;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0, 0, s * 0.42, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1.2;
      ctx.stroke();

      ctx.restore();
    }

    function drawOrb(o, t) {
      ctx.save();
      ctx.translate(o.x, o.y);
      ctx.shadowColor = 'rgba(140,255,0,0.9)';
      ctx.shadowBlur = 18;

      ctx.beginPath();
      ctx.arc(0, 0, o.w * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(140,255,0,' + (0.6 + o.glow * 0.3) + ')';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(0, 0, o.w * 0.25, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.fill();

      ctx.restore();
    }

    function drawHUD() {
      // Score
      ctx.save();
      ctx.font = '700 18px ui-sans-serif, system-ui, -apple-system, Segoe UI';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.textAlign = 'left';
      ctx.fillText('Score: ' + Math.floor(state.score), 18, 28);

      // High score
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.fillText('High: ' + Math.floor(state.hiScore), 18, 52);

      // Energy bar
      const e = Math.max(0, Math.min(100, state.energy));
      const x = W - 200, y = 16, w = 180, h = 18;
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);

      const g = ctx.createLinearGradient(x, y, x + w, y);
      g.addColorStop(0, 'rgba(0,245,255,0.9)');
      g.addColorStop(1, 'rgba(255,196,0,0.9)');

      ctx.fillStyle = g;
      ctx.fillRect(x, y, (e/100) * w, h);

      // Pause/over
      ctx.textAlign = 'center';
      if (state.paused) {
        ctx.font = '700 28px ui-sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillText('Paused', W/2, 44);
      }
      if (!state.player.alive) {
        ctx.font = '800 36px ui-sans-serif';
        ctx.shadowColor = 'rgba(255,45,241,0.6)';
        ctx.shadowBlur = 24;
        ctx.fillStyle = 'rgba(255,45,241,0.95)';
        ctx.fillText('Game Over', W/2, H/2 - 24);

        ctx.font = '600 18px ui-sans-serif';
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillText('Press Reset to try again', W/2, H/2 + 12);
      }
      ctx.restore();
    }

    // Update
    let last = 0;
    function loop(ts) {
      if (!state.running) return;
      const dt = Math.min(0.033, (ts - last) / 1000); // clamp
      last = ts;
      if (!state.paused) update(dt);
      render(dt, ts);
      requestAnimationFrame(loop);
    }

    function update(dt) {
      if (!state.player.alive) return;

      state.time += dt;
      state.score += dt * (60 + state.difficulty * 8);

      // Difficulty ramp
      state.difficulty = 1 + Math.min(10, state.time * 0.12);

      // Player movement
      const p = state.player;
      const accel = 900;
      const maxSpeed = 380 + state.difficulty * 10;

      if (input.left) p.vx -= accel * dt;
      if (input.right) p.vx += accel * dt;

      // Friction
      p.vx *= 0.92;

      // Clamp and move
      p.vx = Math.max(-maxSpeed, Math.min(maxSpeed, p.vx));
      p.x += p.vx * dt;
      p.x = Math.max(p.w/2, Math.min(W - p.w/2, p.x));

      // Dash
      p.cool = Math.max(0, p.cool - dt);
      if (input.dash && p.cool <= 0 && state.energy >= 20) {
        p.dash = 0.22; // seconds
        p.cool = 0.6;
        state.energy -= 20;
        for (let i = 0; i < 18; i++) addTrail(p.x, p.y, 'rgba(255,196,0,0.7)');
      }
      p.dash = Math.max(0, p.dash - dt);
      if (p.dash > 0) {
        p.vx *= 1.06;
        // Invulnerable while dashing
      }

      // Energy regen
      state.energy = Math.min(100, state.energy + dt * 6);

      // Spawns
      if (Math.random() < 0.02 + state.difficulty * 0.004) spawnHazard();
      if (Math.random() < 0.012 + state.difficulty * 0.002) spawnOrb();

      // Hazards update
      for (const h of state.hazards) {
        h.y += h.vy;
        h.rot += h.rotSpeed;
      }
      // Orbs update
      for (const o of state.orbs) {
        o.y += o.vy;
      }
      // Trails fade
      for (const t of state.trails) {
        t.life -= dt;
        t.r *= 0.98;
      }
      state.trails = state.trails.filter(t => t.life > 0.02);

      // Collisions
      // Hazards
      for (const h of state.hazards) {
        if (h.y - h.h/2 > H + 10) continue;
        if (p.dash > 0) continue; // invulnerable
        if (collide(p, h)) {
          state.player.alive = false;
          state.hiScore = Math.max(state.hiScore, Math.floor(state.score));
          localStorage.setItem('neon_hi', String(state.hiScore));
          break;
        }
      }
      // Orbs
      state.orbs = state.orbs.filter(o => {
        if (o.y - o.h/2 > H + 10) return false;
        if (collide(state.player, o)) {
          state.score += 100;
          state.energy = Math.min(100, state.energy + 18);
          for (let i = 0; i < 10; i++) addTrail(o.x, o.y, 'rgba(140,255,0,0.8)');
          return false;
        }
        return true;
      });
      // Clean hazards past screen
      state.hazards = state.hazards.filter(h => h.y - h.h/2 <= H + 20);
    }

    function render(dt, ts) {
      ctx.clearRect(0, 0, W, H);

      // Dim backdrop
      ctx.fillStyle = 'rgba(10, 15, 30, 0.9)';
      ctx.fillRect(0, 0, W, H);

      drawStarfield(dt);

      // Trails
      for (const t of state.trails) {
        ctx.beginPath();
        ctx.arc(t.x + rand(-2, 2), t.y + rand(-2, 2), Math.max(0, t.r), 0, Math.PI * 2);
        ctx.fillStyle = t.color;
        ctx.fill();
      }

      // Hazards
      for (const h of state.hazards) drawHazard(h, ts);

      // Orbs
      for (const o of state.orbs) drawOrb(o, ts);

      // Player
      drawPlayer(state.player, ts);

      // HUD
      drawHUD();
    }

    // Auto-start
    startGame();

    // Resize handling: keep internal resolution, canvas CSS scales.
    window.addEventListener('resize', () => {
      // No-op: CSS scales the canvas responsively.
    });
  </script>
</body>
</html>
